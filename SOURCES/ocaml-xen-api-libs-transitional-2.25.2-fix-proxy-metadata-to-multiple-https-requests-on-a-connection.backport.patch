From 26802fe1acacfcf78502e437328ee4bbc7c6a87e Mon Sep 17 00:00:00 2001
From: Samuel Verschelde <stormi-xcp@ylix.fr>
Date: Thu, 9 Sep 2021 16:28:20 +0000
Subject: [PATCH] CA-358583: Fix PROXY metadata to multiple HTTPS requests on a
 connection

When stunnel is configured with `protocol = proxy`, it will send a PROXY
header right at the beginning after establishing a connection to the
server, before passing on any decrypted data from the client. This
header contains useful TCP parameters, such as the source IP (see
04dd088). Even if this connection ends up carrying multiple HTTP(S)
requests, there will only be one PROXY header sent, as stunnel doesn't
interpret the data.

The HTTP server, however, looks for the PROXY header and HTTP header in
one step. So the first request on the connection gets annotated with
this PROXY data, and any following requests on the same connection do
not. It doesn't remember that it had already seen the PROXY header. This
is easily fixed in the receive loop by passing on a PROXY header once
one has been seen.

Backported from commit 4b14f357ac4a39e224a48e07053e11915b9dc44d, that
was originally written by Rob Hoes <rob.hoes@citrix.com>.

Several conflicts solved, due to formatting changes and refactoring.

Signed-off-by: Samuel Verschelde <stormi-xcp@ylix.fr>
---
 http-svr/http_proxy.ml |   2 +-
 http-svr/http_svr.ml   | 162 +++++++++++++++++++++++------------------
 http-svr/http_svr.mli  |   7 +-
 3 files changed, 99 insertions(+), 72 deletions(-)

diff --git a/http-svr/http_proxy.ml b/http-svr/http_proxy.ml
index fd4af3e..a757df6 100644
--- a/http-svr/http_proxy.ml
+++ b/http-svr/http_proxy.ml
@@ -55,7 +55,7 @@ let http_proxy src_ip src_port transport =
     finally
       (fun () ->
          let bio = Buf_io.of_fd fromfd in
-         let request = Http_svr.request_of_bio bio in
+         let request, _ = Http_svr.request_of_bio bio in
          Opt.iter
            (fun request ->
               with_transport transport (one request fromfd)
diff --git a/http-svr/http_svr.ml b/http-svr/http_svr.ml
index ab07893..8356caa 100644
--- a/http-svr/http_svr.ml
+++ b/http-svr/http_svr.ml
@@ -328,79 +328,92 @@ let request_of_bio_exn_slow ic =
       else (k, v) :: (read_rest_of_headers (left - 1))
     | None -> [] in
   let headers = read_rest_of_headers 242 in
-  { req with
-    Request.cookie = (Http.parse_keyvalpairs !cookie);
-    content_length = if !content_length = -1L then None else Some(!content_length);
-    auth = !auth;
-    task = !task;
-    subtask_of = !subtask_of;
-    content_type = !content_type;
-    host = !host;
-    user_agent = !user_agent;
-    additional_headers = headers;
-    accept = !accept;
-  }
+  let request =
+    { req with
+      Request.cookie = (Http.parse_keyvalpairs !cookie);
+      content_length = if !content_length = -1L then None else Some(!content_length);
+      auth = !auth;
+      task = !task;
+      subtask_of = !subtask_of;
+      content_type = !content_type;
+      host = !host;
+      user_agent = !user_agent;
+      additional_headers = headers;
+      accept = !accept;
+    }
+  in
+  (request, None)
 
 (** [request_of_bio_exn ic] reads a single Http.req from [ic] and returns it. On error
     	it simply throws an exception and doesn't touch the output stream. *)
 
-let request_of_bio_exn bio =
+let request_of_bio_exn ~proxy_seen bio =
   let fd = Buf_io.fd_of bio in
-  let frame, headers, proxy = Http.read_http_request_header fd in
+  let frame, headers, proxy' = Http.read_http_request_header fd in
+  let proxy = match proxy' with None -> proxy_seen | x -> x in
   let additional_headers = proxy |> Option.fold ~none:[] ~some:(fun p -> [("STUNNEL_PROXY", p)]) in
   let open Http.Request in
-  Astring.String.cuts ~sep:"\n" headers |> List.fold_left
-        (fun (status, req) header ->
-           if not status then begin
-             match Astring.String.fields ~empty:false header with
-             | [ meth; uri; version ] ->
-               (* Request-Line   = Method SP Request-URI SP HTTP-Version CRLF *)
-               let uri, query = Http.parse_uri uri in
-               let m = Http.method_t_of_string meth in
-               let version =
-                 let x = String.trim version in
-                 let prefix = "HTTP/" in
-                 String.sub x (String.length prefix) (String.length x - (String.length prefix)) in
-               let close = version = "1.0" in
-               true,
-               { req with m = m; uri = uri; query = query;
-                          version = version; close = close
-               }
-             | _ -> raise Http_parse_failure
-           end else begin
-             match Astring.String.cut ~sep:":" header with
-             | Some (k, v) ->
-               let k = lowercase k in
-               let v = String.trim v in
-               true, begin match k with
-                 | k when k = Http.Hdr.content_length -> { req with content_length = Some (Int64.of_string v) }
-                 | k when k = Http.Hdr.cookie -> { req with cookie = Http.parse_keyvalpairs v }
-                 | k when k = Http.Hdr.transfer_encoding -> { req with transfer_encoding = Some v }
-                 | k when k = Http.Hdr.accept -> { req with accept = Some v }
-                 | k when k = Http.Hdr.authorization -> { req with auth = Some(authorization_of_string v) }
-                 | k when k = Http.Hdr.task_id -> { req with task = Some v }
-                 | k when k = Http.Hdr.subtask_of -> { req with subtask_of = Some v }
-                 | k when k = Http.Hdr.content_type -> { req with content_type = Some v }
-                 | k when k = Http.Hdr.host -> { req with host = Some v }
-                 | k when k = Http.Hdr.user_agent -> { req with user_agent = Some v }
-                 | k when k = Http.Hdr.connection && lowercase v = "close" -> { req with close = true }
-                 | k when k = Http.Hdr.connection && lowercase v = "keep-alive" -> { req with close = false }
-                 | _ -> { req with additional_headers = (k, v) :: req.additional_headers }
-               end
-             | None -> true, req (* end of headers *)
-           end
-        ) (false, { empty with Http.Request.frame = frame ; additional_headers }) |> snd
-
+  let request = 
+    Astring.String.cuts ~sep:"\n" headers |> List.fold_left
+          (fun (status, req) header ->
+             if not status then begin
+               match Astring.String.fields ~empty:false header with
+               | [ meth; uri; version ] ->
+                 (* Request-Line   = Method SP Request-URI SP HTTP-Version CRLF *)
+                 let uri, query = Http.parse_uri uri in
+                 let m = Http.method_t_of_string meth in
+                 let version =
+                   let x = String.trim version in
+                   let prefix = "HTTP/" in
+                   String.sub x (String.length prefix) (String.length x - (String.length prefix)) in
+                 let close = version = "1.0" in
+                 true,
+                 { req with m = m; uri = uri; query = query;
+                            version = version; close = close
+                 }
+               | _ -> raise Http_parse_failure
+             end else begin
+               match Astring.String.cut ~sep:":" header with
+               | Some (k, v) ->
+                 let k = lowercase k in
+                 let v = String.trim v in
+                 true, begin match k with
+                   | k when k = Http.Hdr.content_length -> { req with content_length = Some (Int64.of_string v) }
+                   | k when k = Http.Hdr.cookie -> { req with cookie = Http.parse_keyvalpairs v }
+                   | k when k = Http.Hdr.transfer_encoding -> { req with transfer_encoding = Some v }
+                   | k when k = Http.Hdr.accept -> { req with accept = Some v }
+                   | k when k = Http.Hdr.authorization -> { req with auth = Some(authorization_of_string v) }
+                   | k when k = Http.Hdr.task_id -> { req with task = Some v }
+                   | k when k = Http.Hdr.subtask_of -> { req with subtask_of = Some v }
+                   | k when k = Http.Hdr.content_type -> { req with content_type = Some v }
+                   | k when k = Http.Hdr.host -> { req with host = Some v }
+                   | k when k = Http.Hdr.user_agent -> { req with user_agent = Some v }
+                   | k when k = Http.Hdr.connection && lowercase v = "close" -> { req with close = true }
+                   | k when k = Http.Hdr.connection && lowercase v = "keep-alive" -> { req with close = false }
+                   | _ -> { req with additional_headers = (k, v) :: req.additional_headers }
+                 end
+               | None -> true, req (* end of headers *)
+             end
+          ) (false, { empty with Http.Request.frame = frame ; additional_headers }) |> snd
+  in
+  (request, proxy)
 (** [request_of_bio ic] returns [Some req] read from [ic], or [None]. If [None] it will have
     	already sent back a suitable error code and response to the client. *)
-let request_of_bio ?(use_fastpath=false) ic =
+let request_of_bio ?(use_fastpath=false) ?proxy_seen ic =
   try
-    let r = (if use_fastpath then request_of_bio_exn else request_of_bio_exn_slow) ic in
-(*
+    let r, proxy =
+      ( if use_fastpath then
+          request_of_bio_exn ~proxy_seen
+      else
+        request_of_bio_exn_slow
+      )
+        ic
+    in
+    (*
 		Printf.fprintf stderr "Parsed [%s]\n" (Http.Request.to_wire_string r);
 		flush stderr;
 *)
-    Some r
+    (Some r, proxy)
   with e ->
     D.warn "%s (%s)" (Printexc.to_string e) __LOC__;
     best_effort (fun () ->
@@ -428,7 +441,7 @@ let request_of_bio ?(use_fastpath=false) ic =
           response_internal_error ss ~extra:(escape (Printexc.to_string exc));
           log_backtrace ();
       );
-    None
+    (None, None)
 
 let handle_one (x: 'a Server.t) ss context req =
   let ic = Buf_io.of_fd ss in
@@ -473,16 +486,27 @@ let handle_one (x: 'a Server.t) ss context req =
 
 let handle_connection (x: 'a Server.t) _ ss =
   let ic = Buf_io.of_fd ss in
-  let finished = ref false in
-
-  while not !finished do
+  (* For HTTPS requests, a PROXY header is sent by stunnel right at the beginning of
+     of its connection to the server, before HTTP requests are transferred, and
+     just once per connection. To allow for the PROXY metadata (including e.g. the
+     client IP) to be added to all request records on a connection, it must be passed
+     along in the loop below. *)
+  let rec loop proxy_seen =
     (* 1. we must successfully parse a request *)
-    let req = request_of_bio ~use_fastpath:x.Server.use_fastpath ic in
-
+    let req, proxy =
+      request_of_bio ~use_fastpath:x.Server.use_fastpath ?proxy_seen ic
+    in
     (* 2. now we attempt to process the request *)
-    finished := Opt.default true (Opt.map (handle_one x ss x.Server.default_context) req);
-  done;
-  Unix.close ss
+    let finished =
+      Option.fold ~none:true
+        ~some:(handle_one x ss x.Server.default_context)
+        req
+    in
+    (* 3. do it again if the connection is kept open *)
+    if not finished then
+      loop proxy
+  in
+  loop None ; Unix.close ss
 
 let bind ?(listen_backlog=128) sockaddr name =
   let domain = match sockaddr with
diff --git a/http-svr/http_svr.mli b/http-svr/http_svr.mli
index 854bc9d..b64c954 100644
--- a/http-svr/http_svr.mli
+++ b/http-svr/http_svr.mli
@@ -104,5 +104,8 @@ val respond_to_options : Http.Request.t -> Unix.file_descr -> unit
 
 val headers : Unix.file_descr -> string list -> unit
 val read_body : ?limit:int -> Http.Request.t -> Buf_io.t -> string
-val request_of_bio: ?use_fastpath:bool -> Buf_io.t -> Http.Request.t option
-
+val request_of_bio :
+     ?use_fastpath:bool
+  -> ?proxy_seen:string
+  -> Buf_io.t
+  -> Http.Request.t option * string option
-- 
2.30.2

