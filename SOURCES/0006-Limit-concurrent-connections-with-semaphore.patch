From a2f407e26cee823703fbb064b72b52c29842425c Mon Sep 17 00:00:00 2001
From: Rob Hoes <rob.hoes@citrix.com>
Date: Fri, 19 Aug 2022 10:17:02 +0000
Subject: [PATCH 6/9] Limit concurrent connections with semaphore

To add some protection against overloading the server, and running out
of file descriptors and other resources, the number of concurrent
connections is now limited to 800 by default. Connections coming in when
the limit has been reached are put on hold, and not accepted until
another connection finishes.

There are three separate buckets for connections to the main unix
socket, the client-cert (unix) socket and the TCP socket.

This also add some more debug logging when connections are accepted and
disconnected. This is disabled by default along with other "http" logs,
but can be enabled in the conf file.

Signed-off-by: Rob Hoes <rob.hoes@citrix.com>

(cherry picked from commit 31d35ed6fe5974f1c2de24581bc076f5b5c6ac7e)
---
 http-svr/http_svr.ml    | 26 ++++++++++++++++++++++----
 http-svr/http_svr.mli   |  2 +-
 http-svr/server_io.ml   | 18 +++++++++++-------
 http-svr/server_io.mli  |  1 +
 http-svr/test_server.ml |  2 +-
 5 files changed, 36 insertions(+), 13 deletions(-)

diff --git a/http-svr/http_svr.ml b/http-svr/http_svr.ml
index 5c0909de5..ea59dd608 100644
--- a/http-svr/http_svr.ml
+++ b/http-svr/http_svr.ml
@@ -108,6 +108,7 @@ let response_fct req ?(hdrs = []) s (response_length : int64)
       Http.Response.content_length= Some response_length
     }
   in
+  D.debug "Response %s" (Http.Response.to_string res) ;
   Unixext.really_write_string s (Http.Response.to_wire_string res) ;
   write_response_to_fd_fn s
 
@@ -125,6 +126,7 @@ let response_missing ?(hdrs = []) s body =
       ~headers:(connection :: cache :: hdrs)
       ~body "404" "Not Found"
   in
+  D.debug "Response %s" (Http.Response.to_string res) ;
   Unixext.really_write_string s (Http.Response.to_wire_string res)
 
 let response_error_html ?(version = "1.1") s code message hdrs body =
@@ -136,6 +138,7 @@ let response_error_html ?(version = "1.1") s code message hdrs body =
       ~headers:(content_type :: connection :: cache :: hdrs)
       ~body code message
   in
+  D.debug "Response %s" (Http.Response.to_string res) ;
   Unixext.really_write_string s (Http.Response.to_wire_string res)
 
 let response_unauthorised ?req label s =
@@ -486,7 +489,15 @@ let handle_one (x : 'a Server.t) ss context req =
     ) ;
     !finished
 
-let handle_connection (x : 'a Server.t) _ ss =
+let handle_connection (x : 'a Server.t) caller ss =
+  ( match caller with
+  | Unix.ADDR_UNIX _ ->
+      debug "Accepted unix connection"
+  | Unix.ADDR_INET (addr, port) ->
+      debug "Accepted inet connection from %s:%d"
+        (Unix.string_of_inet_addr addr)
+        port
+  ) ;
   let ic = Buf_io.of_fd ss in
   (* For HTTPS requests, a PROXY header is sent by stunnel right at the beginning of
      of its connection to the server, before HTTP requests are transferred, and
@@ -506,7 +517,7 @@ let handle_connection (x : 'a Server.t) _ ss =
     if not finished then
       loop proxy
   in
-  loop None ; Unix.close ss
+  loop None ; debug "Closing connection" ; Unix.close ss
 
 let bind ?(listen_backlog = 128) sockaddr name =
   let domain =
@@ -572,8 +583,15 @@ let socket_table = Hashtbl.create 10
 type socket = Unix.file_descr * string
 
 (* Start an HTTP server on a new socket *)
-let start (x : 'a Server.t) (socket, name) =
-  let handler = {Server_io.name; body= handle_connection x} in
+let start ~conn_limit (x : 'a Server.t) (socket, name)
+    =
+let handler =
+    {
+      Server_io.name
+    ; body= handle_connection x
+    ; lock= Xapi_stdext_threads.Semaphore.create conn_limit
+    }
+  in
   let server = Server_io.server handler socket in
   Hashtbl.add socket_table socket server
 
diff --git a/http-svr/http_svr.mli b/http-svr/http_svr.mli
index 3781c7eee..d0c79e4d4 100644
--- a/http-svr/http_svr.mli
+++ b/http-svr/http_svr.mli
@@ -59,7 +59,7 @@ val bind : ?listen_backlog:int -> Unix.sockaddr -> string -> socket
 (* [bind_retry]: like [bind] but will catch (possibly transient exceptions) and retry *)
 val bind_retry : ?listen_backlog:int -> Unix.sockaddr -> socket
 
-val start : 'a Server.t -> socket -> unit
+val start : conn_limit:int -> 'a Server.t -> socket -> unit
 
 val handle_one : 'a Server.t -> Unix.file_descr -> 'a -> Http.Request.t -> bool
 
diff --git a/http-svr/server_io.ml b/http-svr/server_io.ml
index 8236f5f6a..fd53265fc 100644
--- a/http-svr/server_io.ml
+++ b/http-svr/server_io.ml
@@ -23,12 +23,17 @@ type handler = {
     name: string
   ; (* body should close the provided fd *)
     body: Unix.sockaddr -> Unix.file_descr -> unit
+  ; lock: Xapi_stdext_threads.Semaphore.t
 }
 
 let handler_by_thread (h : handler) (s : Unix.file_descr)
     (caller : Unix.sockaddr) =
   Thread.create
-    (fun () -> Debug.with_thread_named h.name (fun () -> h.body caller s) ())
+    (fun () ->
+      Fun.protect
+        ~finally:(fun () -> Xapi_stdext_threads.Semaphore.release h.lock 1)
+        (Debug.with_thread_named h.name (fun () -> h.body caller s))
+    )
     ()
 
 (** Function with the main accept loop *)
@@ -42,7 +47,7 @@ type sock_or_addr =
   | Server_sockaddr of Unix.sockaddr
   | Server_fd of Unix.file_descr
 
-let establish_server ?(signal_fds = []) forker sockoraddr =
+let establish_server ?(signal_fds = []) forker handler sockoraddr =
   let sock =
     match sockoraddr with
     | Server_sockaddr sockaddr ->
@@ -69,11 +74,11 @@ let establish_server ?(signal_fds = []) forker sockoraddr =
       let r, _, _ = Unix.select ([sock] @ signal_fds) [] [] (-1.) in
       (* If any of the signal_fd is active then bail out *)
       if set_intersect r signal_fds <> [] then raise PleaseClose ;
-
+      Xapi_stdext_threads.Semaphore.acquire handler.lock 1 ;
       let s, caller = Unix.accept sock in
       try
         Unix.set_close_on_exec s ;
-        ignore (forker s caller)
+        ignore (forker handler s caller)
       with exc ->
         (* NB provided 'forker' is configured to make a background thread then the
            	     only way we can get here is if set_close_on_exec or Thread.create fails.
@@ -116,9 +121,8 @@ let server handler sock =
         Debug.with_thread_named handler.name
           (fun () ->
             try
-              establish_server ~signal_fds:[status_out]
-                (handler_by_thread handler)
-                (Server_fd sock)
+              establish_server ~signal_fds:[status_out] handler_by_thread
+                handler (Server_fd sock)
             with PleaseClose -> debug "Server thread exiting"
           )
           ()
diff --git a/http-svr/server_io.mli b/http-svr/server_io.mli
index b48952f89..3aca02347 100644
--- a/http-svr/server_io.mli
+++ b/http-svr/server_io.mli
@@ -16,6 +16,7 @@ type handler = {
     name: string  (** used for naming the thread *)
   ; body: Unix.sockaddr -> Unix.file_descr -> unit
         (** function called in a thread for each connection*)
+  ; lock: Xapi_stdext_threads.Semaphore.t
 }
 
 type server = {
diff --git a/http-svr/test_server.ml b/http-svr/test_server.ml
index f7256d939..69925983e 100644
--- a/http-svr/test_server.ml
+++ b/http-svr/test_server.ml
@@ -68,7 +68,7 @@ let _ =
   let inet_addr = Unix.inet_addr_of_string ip in
   let addr = Unix.ADDR_INET (inet_addr, !port) in
   let socket = Http_svr.bind ~listen_backlog:5 addr "server" in
-  start server socket ;
+  start ~conn_limit:1024 server socket ;
   Printf.printf "Server started on %s:%d\n" ip !port ;
   Mutex.execute finished_m (fun () ->
       while not !finished do
-- 
2.31.1

