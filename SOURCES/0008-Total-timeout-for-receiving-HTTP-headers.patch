From 58500780f606e195ea5464cf1a36bcb16fb981b9 Mon Sep 17 00:00:00 2001
From: Rob Hoes <rob.hoes@citrix.com>
Date: Tue, 26 Jul 2022 14:57:42 +0000
Subject: [PATCH 8/9] Total timeout for receiving HTTP headers

Signed-off-by: Rob Hoes <rob.hoes@citrix.com>

(cherry picked from commit 6fd74ea706fd2fd767be691daffe88a3c227814e)
(the patch applied cleanly, but needed a change for the older version of
mtime on this branch)
---
 http-svr/http.ml      | 42 ++++++++++++++++++++++++++++++++++--------
 http-svr/http.mli     |  7 ++++++-
 http-svr/http_svr.ml  | 33 +++++++++++++++++++++------------
 http-svr/http_svr.mli |  7 ++++++-
 http-svr/http_test.ml |  3 ++-
 5 files changed, 69 insertions(+), 23 deletions(-)

diff --git a/http-svr/http.ml b/http-svr/http.ml
index 0c23b46db..2c87180c3 100644
--- a/http-svr/http.ml
+++ b/http-svr/http.ml
@@ -27,6 +27,8 @@ exception Method_not_implemented
 
 exception Malformed_url of string
 
+exception Timeout
+
 module D = Debug.Make (struct let name = "http" end)
 
 open D
@@ -282,7 +284,7 @@ let header_len_header = Printf.sprintf "\r\n%s:" Hdr.header_len
 
 let header_len_value_len = 5
 
-let read_up_to buf already_read marker fd =
+let read_up_to ?deadline buf already_read marker fd =
   let marker = Scanner.make marker in
   let hl_marker = Scanner.make header_len_header in
   let b = ref 0 in
@@ -291,6 +293,12 @@ let read_up_to buf already_read marker fd =
   let header_len = ref None in
   let header_len_value_at = ref None in
   while not (Scanner.matched marker) do
+    Option.iter
+      (fun d ->
+        if Mtime.Span.compare (Mtime_clock.elapsed ()) d > 0 then
+          raise Timeout
+      )
+      deadline ;
     let safe_to_read =
       match (!header_len_value_at, !header_len) with
       | None, None ->
@@ -371,29 +379,47 @@ let set_socket_timeout fd t =
     (* In the unit tests, the fd comes from a pipe... ignore *)
     ()
 
-let read_http_request_header ~read_timeout fd =
+let read_http_request_header ~read_timeout ~total_timeout fd =
   Option.iter (fun t -> set_socket_timeout fd t) read_timeout ;
   let buf = Bytes.create 1024 in
-  Unixext.really_read fd buf 0 6 ;
+  let deadline =
+    Option.map
+      (fun t ->
+        let start = Mtime_clock.elapsed () in
+        let timeout_ns = Int64.of_float (t *. 1e9) in
+        Mtime.Span.(add start (of_uint64_ns timeout_ns))
+      )
+      total_timeout
+  in
+  let check_timeout_and_read x y =
+    Option.iter
+      (fun d ->
+        if Mtime.Span.compare (Mtime_clock.elapsed ()) d > 0 then
+          raise Timeout
+      )
+      deadline ;
+    Unixext.really_read fd buf x y
+  in
+  check_timeout_and_read 0 6 ;
   (* return PROXY header if it exists, and then read up to FRAME header length (which also may not exist) *)
   let proxy =
     match Bytes.sub_string buf 0 6 with
     | "PROXY " ->
-        let proxy_header_length = read_up_to buf 6 "\r\n" fd in
+        let proxy_header_length = read_up_to ?deadline buf 6 "\r\n" fd in
         (* chop 'PROXY ' from the beginning, and '\r\n' from the end *)
         let proxy = Bytes.sub_string buf 6 (proxy_header_length - 6 - 2) in
-        Unixext.really_read fd buf 0 frame_header_length ;
+        check_timeout_and_read 0 frame_header_length ;
         Some proxy
     | _ ->
-        Unixext.really_read fd buf 6 (frame_header_length - 6) ;
+        check_timeout_and_read 6 (frame_header_length - 6) ;
         None
   in
   let frame, headers_length =
     match read_frame_header buf with
     | None ->
-        (false, read_up_to buf frame_header_length end_of_headers fd)
+        (false, read_up_to ?deadline buf frame_header_length end_of_headers fd)
     | Some length ->
-        Unixext.really_read fd buf 0 length ;
+        check_timeout_and_read 0 length ;
         (true, length)
   in
   set_socket_timeout fd 0. ;
diff --git a/http-svr/http.mli b/http-svr/http.mli
index 129e03b92..9a090831d 100644
--- a/http-svr/http.mli
+++ b/http-svr/http.mli
@@ -27,12 +27,17 @@ exception Method_not_implemented
 
 exception Forbidden
 
+exception Timeout
+
 type authorization = Basic of string * string | UnknownAuth of string
 
 val make_frame_header : string -> string
 
 val read_http_request_header :
-  read_timeout:float option -> Unix.file_descr -> bool * string * string option
+     read_timeout:float option
+  -> total_timeout:float option
+  -> Unix.file_descr
+  -> bool * string * string option
 
 val read_http_response_header : bytes -> Unix.file_descr -> int
 
diff --git a/http-svr/http_svr.ml b/http-svr/http_svr.ml
index f99ac99df..b5280e907 100644
--- a/http-svr/http_svr.ml
+++ b/http-svr/http_svr.ml
@@ -325,9 +325,11 @@ exception Generic_error of string
 
 (** [request_of_bio_exn ic] reads a single Http.req from [ic] and returns it. On error
     	it simply throws an exception and doesn't touch the output stream. *)
-let request_of_bio_exn ~proxy_seen ~read_timeout bio =
+let request_of_bio_exn ~proxy_seen ~read_timeout ~total_timeout bio =
   let fd = Buf_io.fd_of bio in
-  let frame, headers, proxy' = Http.read_http_request_header ~read_timeout fd in
+  let frame, headers, proxy' =
+    Http.read_http_request_header ~read_timeout ~total_timeout fd
+  in
   let proxy = match proxy' with None -> proxy_seen | x -> x in
   let additional_headers =
     proxy |> Option.fold ~none:[] ~some:(fun p -> [("STUNNEL_PROXY", p)])
@@ -403,9 +405,11 @@ let request_of_bio_exn ~proxy_seen ~read_timeout bio =
 
 (** [request_of_bio ic] returns [Some req] read from [ic], or [None]. If [None] it will have
     	already sent back a suitable error code and response to the client. *)
-let request_of_bio ?proxy_seen ~read_timeout ic =
+let request_of_bio ?proxy_seen ~read_timeout ~total_timeout ic =
   try
-    let r, proxy = request_of_bio_exn ~proxy_seen ~read_timeout ic in
+    let r, proxy =
+      request_of_bio_exn ~proxy_seen ~read_timeout ~total_timeout ic
+    in
     (Some r, proxy)
   with e ->
     D.warn "%s (%s)" (Printexc.to_string e) __LOC__ ;
@@ -429,7 +433,7 @@ let request_of_bio ?proxy_seen ~read_timeout ic =
         (* Generic errors thrown during parsing *)
         | End_of_file ->
             ()
-        | Unix.Unix_error (Unix.EAGAIN, _, _) ->
+        | Unix.Unix_error (Unix.EAGAIN, _, _) | Http.Timeout ->
             response_request_timeout ss
         (* Premature termination of connection! *)
         | Unix.Unix_error (a, b, c) ->
@@ -498,7 +502,8 @@ let handle_one (x : 'a Server.t) ss context req =
     ) ;
     !finished
 
-let handle_connection ~header_read_timeout (x : 'a Server.t) caller ss =
+let handle_connection ~header_read_timeout ~header_total_timeout
+    (x : 'a Server.t) caller ss =
   ( match caller with
   | Unix.ADDR_UNIX _ ->
       debug "Accepted unix connection"
@@ -513,9 +518,11 @@ let handle_connection ~header_read_timeout (x : 'a Server.t) caller ss =
      just once per connection. To allow for the PROXY metadata (including e.g. the
      client IP) to be added to all request records on a connection, it must be passed
      along in the loop below. *)
-  let rec loop ~read_timeout proxy_seen =
+  let rec loop ~read_timeout ~total_timeout proxy_seen =
     (* 1. we must successfully parse a request *)
-    let req, proxy = request_of_bio ?proxy_seen ~read_timeout ic in
+    let req, proxy =
+      request_of_bio ?proxy_seen ~read_timeout ~total_timeout ic
+    in
     (* 2. now we attempt to process the request *)
     let finished =
       Option.fold ~none:true
@@ -524,9 +531,10 @@ let handle_connection ~header_read_timeout (x : 'a Server.t) caller ss =
     in
     (* 3. do it again if the connection is kept open, but without timeouts *)
     if not finished then
-      loop ~read_timeout:None proxy
+      loop ~read_timeout:None ~total_timeout:None proxy
   in
-  loop ~read_timeout:header_read_timeout None ;
+  loop ~read_timeout:header_read_timeout ~total_timeout:header_total_timeout
+    None ;
   debug "Closing connection" ;
   Unix.close ss
 
@@ -594,11 +602,12 @@ let socket_table = Hashtbl.create 10
 type socket = Unix.file_descr * string
 
 (* Start an HTTP server on a new socket *)
-let start ?header_read_timeout ~conn_limit (x : 'a Server.t) (socket, name) =
+let start ?header_read_timeout ?header_total_timeout ~conn_limit
+    (x : 'a Server.t) (socket, name) =
   let handler =
     {
       Server_io.name
-    ; body= handle_connection ~header_read_timeout x
+    ; body= handle_connection ~header_read_timeout ~header_total_timeout x
     ; lock= Xapi_stdext_threads.Semaphore.create conn_limit
     }
   in
diff --git a/http-svr/http_svr.mli b/http-svr/http_svr.mli
index 40a5074ea..761e39436 100644
--- a/http-svr/http_svr.mli
+++ b/http-svr/http_svr.mli
@@ -60,7 +60,12 @@ val bind : ?listen_backlog:int -> Unix.sockaddr -> string -> socket
 val bind_retry : ?listen_backlog:int -> Unix.sockaddr -> socket
 
 val start :
-  ?header_read_timeout:float -> conn_limit:int -> 'a Server.t -> socket -> unit
+     ?header_read_timeout:float
+  -> ?header_total_timeout:float
+  -> conn_limit:int
+  -> 'a Server.t
+  -> socket
+  -> unit
 
 val handle_one : 'a Server.t -> Unix.file_descr -> 'a -> Http.Request.t -> bool
 
diff --git a/http-svr/http_test.ml b/http-svr/http_test.ml
index b1ac365b1..0543da9e6 100644
--- a/http-svr/http_test.ml
+++ b/http-svr/http_test.ml
@@ -199,7 +199,8 @@ let test_read_http_request_header _ =
   |> List.iter (fun (frame, proxy, header) ->
          with_fd (mk_header_string ~frame ~proxy ~header) (fun fd ->
              let actual_frame, actual_header, actual_proxy =
-               Http.read_http_request_header ~read_timeout:None fd
+               Http.read_http_request_header ~read_timeout:None
+                 ~total_timeout:None fd
              in
              assert (actual_frame = frame) ;
              assert (actual_header = header) ;
-- 
2.31.1

